{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Home","text":"<p>The <code>wulfflow</code> code aims to provide a workflow for quickly creating wulffshape for arbitrary materials. The code makes use of Quacc and Parsl to perform concurrent calculations while aiming to be modular and flexible.</p>"},{"location":"about/conduct.html","title":"Code of Conduct","text":""},{"location":"about/conduct.html#our-pledge","title":"Our Pledge","text":"<p>We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, caste, color, religion, or sexual identity and orientation.</p> <p>We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.</p>"},{"location":"about/conduct.html#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to a positive environment for our community include:</p> <ul> <li>Demonstrating empathy and kindness toward other people</li> <li>Being respectful of differing opinions, viewpoints, and experiences</li> <li>Giving and gracefully accepting constructive feedback</li> <li>Accepting responsibility and apologizing to those affected by our mistakes,   and learning from the experience</li> <li>Focusing on what is best not just for us as individuals, but for the overall   community</li> </ul> <p>Examples of unacceptable behavior include:</p> <ul> <li>The use of sexualized language or imagery, and sexual attention or advances of   any kind</li> <li>Trolling, insulting or derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or email address,   without their explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a   professional setting</li> </ul>"},{"location":"about/conduct.html#enforcement-responsibilities","title":"Enforcement Responsibilities","text":"<p>Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.</p> <p>Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.</p>"},{"location":"about/conduct.html#scope","title":"Scope","text":"<p>This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event.</p>"},{"location":"about/conduct.html#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement. All complaints will be reviewed and investigated promptly and fairly.</p> <p>All community leaders are obligated to respect the privacy and security of the reporter of any incident.</p>"},{"location":"about/conduct.html#enforcement-guidelines","title":"Enforcement Guidelines","text":"<p>Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:</p>"},{"location":"about/conduct.html#1-correction","title":"1. Correction","text":"<p>Community Impact: Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community.</p> <p>Consequence: A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.</p>"},{"location":"about/conduct.html#2-warning","title":"2. Warning","text":"<p>Community Impact: A violation through a single incident or series of actions.</p> <p>Consequence: A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.</p>"},{"location":"about/conduct.html#3-temporary-ban","title":"3. Temporary Ban","text":"<p>Community Impact: A serious violation of community standards, including sustained inappropriate behavior.</p> <p>Consequence: A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.</p>"},{"location":"about/conduct.html#4-permanent-ban","title":"4. Permanent Ban","text":"<p>Community Impact: Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior, harassment of an individual, or aggression toward or disparagement of classes of individuals.</p> <p>Consequence: A permanent ban from any sort of public interaction within the community.</p>"},{"location":"about/conduct.html#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 2.1, available at https://www.contributor-covenant.org/version/2/1/code_of_conduct.html.</p> <p>Community Impact Guidelines were inspired by Mozilla's code of conduct enforcement ladder.</p> <p>For answers to common questions about this code of conduct, see the FAQ at https://www.contributor-covenant.org/faq. Translations are available at https://www.contributor-covenant.org/translations.</p>"},{"location":"about/license.html","title":"License","text":"LICENSE.md<pre><code>BSD 3-Clause License\n\nCopyright (c) 2024\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n1. Redistributions of source code must retain the above copyright notice, this\n   list of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright notice,\n   this list of conditions and the following disclaimer in the documentation\n   and/or other materials provided with the distribution.\n\n3. Neither the name of the copyright holder nor the names of its\n   contributors may be used to endorse or promote products derived from\n   this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n</code></pre>"},{"location":"documentation/examples.html","title":"Examples","text":"<p>A few examples of how to use <code>wulfflow</code> are provided below...</p>"},{"location":"documentation/overview.html","title":"Overview","text":"<p>General principles of the <code>wulfflow</code> package...</p>"},{"location":"installation/install.html","title":"Install","text":"<p>The <code>wulfflow</code> package is not yet available on PyPI, but can be installed from the git repository. To install <code>wulfflow</code>, first clone the repository and then install the package using <code>pip</code>:</p> <pre><code>pip install git+https://github.com/Surface-Tools/wulfflow\n</code></pre>"},{"location":"reference/SUMMARY.html","title":"SUMMARY","text":"<ul> <li>wulfflow<ul> <li>processing<ul> <li>surface_energy</li> <li>wulff_construction</li> </ul> </li> <li>utils<ul> <li>chempot</li> <li>config</li> <li>constants</li> <li>utils</li> </ul> </li> <li>workflow<ul> <li>core</li> <li>generator</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/wulfflow/processing/surface_energy.html","title":"surface_energy","text":""},{"location":"reference/wulfflow/processing/surface_energy.html#wulfflow.processing.surface_energy.analyse_surface_energies","title":"analyse_surface_energies","text":"<pre><code>analyse_surface_energies(surface_energies)\n</code></pre> <p>Analyse the surface energies.</p> <p>Parameters:</p> <ul> <li> <code>surface_energies</code>               (<code>DataFrame</code>)           \u2013            <p>DataFrame containing surface energies and related information.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>           \u2013            <p>Dictionary containing analysis results.</p> </li> </ul> Source code in <code>wulfflow/processing/surface_energy.py</code> <pre><code>def analyse_surface_energies(surface_energies: pd.DataFrame) -&gt; dict[str, Any]:\n    \"\"\"\n    Analyse the surface energies.\n\n    Parameters\n    ----------\n    surface_energies : pd.DataFrame\n        DataFrame containing surface energies and related information.\n\n    Returns\n    -------\n    dict[str, Any]\n        Dictionary containing analysis results.\n    \"\"\"\n    analysis = {\n        \"total_surfaces\": len(surface_energies),\n        \"average_energy\": surface_energies[\"SurfaceEnergy(J/m\u00b2)\"].mean(),\n        \"min_energy\": surface_energies[\"SurfaceEnergy(J/m\u00b2)\"].min(),\n        \"max_energy\": surface_energies[\"SurfaceEnergy(J/m\u00b2)\"].max(),\n        \"most_stable_surface\": surface_energies.loc[\n            surface_energies[\"SurfaceEnergy(J/m\u00b2)\"].idxmin(), \"SlabName\"\n        ],\n        \"least_stable_surface\": surface_energies.loc[\n            surface_energies[\"SurfaceEnergy(J/m\u00b2)\"].idxmax(), \"SlabName\"\n        ],\n    }\n\n    most_stable_by_miller = surface_energies.groupby(\"MillerIndex\").apply(\n        lambda x: x.loc[x[\"SurfaceEnergy(J/m\u00b2)\"].idxmin()]\n    )[[\"SlabName\", \"SurfaceEnergy(J/m\u00b2)\", \"MillerIndex\"]]\n    most_stable_by_miller = most_stable_by_miller.reset_index(drop=True)\n    most_stable_by_miller = most_stable_by_miller.rename(\n        columns={\n            \"SlabName\": \"MostStableSlabName\",\n            \"SurfaceEnergy(J/m\u00b2)\": \"LowestSurfaceEnergy(J/m\u00b2)\",\n        }\n    )\n\n    analysis[\"most_stable_by_miller\"] = most_stable_by_miller.to_dict(orient=\"records\")\n\n    return analysis\n</code></pre>"},{"location":"reference/wulfflow/processing/surface_energy.html#wulfflow.processing.surface_energy.calculate_surface_energies_from_json","title":"calculate_surface_energies_from_json","text":"<pre><code>calculate_surface_energies_from_json(directory, chem_pots, oxide=True)\n</code></pre> <p>Calculate surface energies from JSON files in the given directory.</p> <p>Parameters:</p> <ul> <li> <code>directory</code>               (<code>str</code>)           \u2013            <p>Path to the directory containing JSON files.</p> </li> <li> <code>chem_pots</code>               (<code>dict[str, float]</code>)           \u2013            <p>Dictionary of chemical potentials for each element.</p> </li> <li> <code>oxide</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to include oxygen in calculations. Defaults to True.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>DataFrame containing surface energies and related information.</p> </li> </ul> Source code in <code>wulfflow/processing/surface_energy.py</code> <pre><code>def calculate_surface_energies_from_json(\n    directory: str, chem_pots: dict[str, float], oxide: bool = True\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Calculate surface energies from JSON files in the given directory.\n\n    Parameters\n    ----------\n    directory : str\n        Path to the directory containing JSON files.\n    chem_pots : dict[str, float]\n        Dictionary of chemical potentials for each element.\n    oxide : bool, optional\n        Whether to include oxygen in calculations. Defaults to True.\n\n    Returns\n    -------\n    pd.DataFrame\n        DataFrame containing surface energies and related information.\n    \"\"\"\n    with open(os.path.join(directory, \"references.json\")) as f:\n        references_data = json.load(f)\n    with open(os.path.join(directory, \"slabs.json\")) as f:\n        slabs_data = json.load(f)\n\n    bulk_entry = next(\n        (entry for entry in references_data if entry[\"label\"] != \"O2\"), None\n    )\n    if bulk_entry is None:\n        raise ValueError(\"No bulk structure found in references.json\")\n    bulk_formula = bulk_entry[\"label\"]\n    bulk = json_to_atoms(os.path.join(directory, \"references.json\"), bulk_formula)\n\n    surface_energies = []\n    for slab in slabs_data:\n        slab_atoms = json_to_atoms(os.path.join(directory, \"slabs.json\"), slab[\"label\"])\n        surface_energy = get_surface_energy(slab_atoms, bulk, chem_pots)\n        miller_index = tuple(slab_atoms.info[\"miller_index\"])\n\n        atom_counts = find_element_numbers(slab_atoms)\n\n        surface_energies.append(\n            {\n                \"SlabName\": slab[\"label\"],\n                \"MillerIndex\": miller_index,\n                \"SurfaceEnergy(J/m\u00b2)\": surface_energy,\n                \"ChemicalFormula\": slab_atoms.get_chemical_formula(),\n                \"AtomCounts\": {k: int(v) for k, v in atom_counts.items()},\n                \"UsedChemPots\": chem_pots,\n            }\n        )\n\n    return pd.DataFrame(surface_energies)\n</code></pre>"},{"location":"reference/wulfflow/processing/surface_energy.html#wulfflow.processing.surface_energy.get_surface_energy","title":"get_surface_energy","text":"<pre><code>get_surface_energy(slab, bulk, chem_pots)\n</code></pre> <p>Calculate the surface energy of a slab.</p> <p>Parameters:</p> <ul> <li> <code>slab</code>               (<code>Atoms</code>)           \u2013            <p>The slab structure.</p> </li> <li> <code>bulk</code>               (<code>Atoms</code>)           \u2013            <p>The bulk structure.</p> </li> <li> <code>chem_pots</code>               (<code>dict[str, float]</code>)           \u2013            <p>Dictionary of chemical potentials for each element.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>Surface energy of the slab.</p> </li> </ul> Source code in <code>wulfflow/processing/surface_energy.py</code> <pre><code>def get_surface_energy(slab: Atoms, bulk: Atoms, chem_pots: dict[str, float]) -&gt; float:\n    \"\"\"\n    Calculate the surface energy of a slab.\n\n    Parameters\n    ----------\n    slab : Atoms\n        The slab structure.\n    bulk : Atoms\n        The bulk structure.\n    chem_pots : dict[str, float]\n        Dictionary of chemical potentials for each element.\n\n    Returns\n    -------\n    float\n        Surface energy of the slab.\n    \"\"\"\n    surface_area = np.linalg.norm(np.cross(slab.cell[0], slab.cell[1]))\n    E_slab = slab.info[\"energy\"]\n    E_bulk = bulk.info[\"energy\"]\n\n    slab_element_counts = find_element_numbers(slab)\n    bulk_element_counts = find_element_numbers(bulk)\n\n    bulk_units = min(\n        slab_element_counts[el] // bulk_element_counts[el] for el in bulk_element_counts\n    )\n\n    element_excess = {\n        el: slab_element_counts.get(el, 0)\n        - (bulk_units * bulk_element_counts.get(el, 0))\n        for el in set(slab_element_counts) | set(bulk_element_counts)\n    }\n\n    E_chem_pot = sum(element_excess[el] * chem_pots.get(el, 0) for el in element_excess)\n\n    E_surf = (E_slab - (bulk_units * E_bulk) - E_chem_pot) / (2 * surface_area)\n    return E_surf * CONVERSION_FACTOR\n</code></pre>"},{"location":"reference/wulfflow/processing/wulff_construction.html","title":"wulff_construction","text":""},{"location":"reference/wulfflow/processing/wulff_construction.html#wulfflow.processing.wulff_construction.coverage_plot","title":"coverage_plot","text":"<pre><code>coverage_plot(output_directory, analysis, cif_file_path=CIF_FILE_PATH, element='Li', layer='0', plots=None, figsize=None, rotation=None)\n</code></pre> <p>Generate subplots of Wulff shapes colored by the element relative presence in a specific layer.</p> <p>Parameters:</p> <ul> <li> <code>output_directory</code>               (<code>str</code>)           \u2013            <p>Directory to save the plot.</p> </li> <li> <code>analysis</code>               (<code>dict</code>)           \u2013            <p>Analysis data for plotting.</p> </li> <li> <code>cif_file_path</code>               (<code>str</code>, default:                   <code>CIF_FILE_PATH</code> )           \u2013            <p>Path to the CIF file, by default CIF_FILE_PATH.</p> </li> <li> <code>element</code>               (<code>str</code>, default:                   <code>'Li'</code> )           \u2013            <p>Element to highlight, by default \"Li\".</p> </li> <li> <code>layer</code>               (<code>str</code>, default:                   <code>'0'</code> )           \u2013            <p>Layer to analyze, by default \"0\".</p> </li> <li> <code>plots</code>               (<code>list</code>, default:                   <code>None</code> )           \u2013            <p>Plot grid dimensions, by default None.</p> </li> <li> <code>figsize</code>               (<code>list</code>, default:                   <code>None</code> )           \u2013            <p>Figure size, by default None.</p> </li> <li> <code>rotation</code>               (<code>list</code>, default:                   <code>None</code> )           \u2013            <p>Rotation angles, by default None.</p> </li> </ul> Source code in <code>wulfflow/processing/wulff_construction.py</code> <pre><code>def coverage_plot(\n    output_directory,\n    analysis,\n    cif_file_path=CIF_FILE_PATH,\n    element=\"Li\",\n    layer=\"0\",\n    plots=None,\n    figsize=None,\n    rotation=None,\n):\n    \"\"\"\n    Generate subplots of Wulff shapes colored by the element relative presence in a specific layer.\n\n    Parameters\n    ----------\n    output_directory : str\n        Directory to save the plot.\n    analysis : dict\n        Analysis data for plotting.\n    cif_file_path : str, optional\n        Path to the CIF file, by default CIF_FILE_PATH.\n    element : str, optional\n        Element to highlight, by default \"Li\".\n    layer : str, optional\n        Layer to analyze, by default \"0\".\n    plots : list, optional\n        Plot grid dimensions, by default None.\n    figsize : list, optional\n        Figure size, by default None.\n    rotation : list, optional\n        Rotation angles, by default None.\n    \"\"\"\n\n    if rotation is None:\n        rotation = [\n            (0, 0, 0),\n            (0, 45, 0),\n            (0, 90, 0),\n            (0, 135, 0),\n            (45, 0, 0),\n            (45, 45, 0),\n            (45, 90, 0),\n            (45, 135, 0),\n            (90, 0, 0),\n            (90, 45, 0),\n            (90, 90, 0),\n            (90, 135, 0),\n            (135, 0, 0),\n            (135, 45, 0),\n            (135, 90, 0),\n            (135, 135, 0),\n        ]\n    if figsize is None:\n        figsize = [15, 15]\n    if plots is None:\n        plots = [4, 4]\n    with open(\"wulff_data.json\") as f:\n        data = json.load(f)\n    wulff_dict = {}\n    for surface in data[\"coverage\"]:\n        for tup in data[\"coverage\"][surface][layer]:\n            if tup[0] == element:\n                wulff_dict[surface] = tup[1]\n\n    vmin, vmax = 0, max(wulff_dict.values())\n    norm = colors.Normalize(vmin=vmin, vmax=vmax)\n    cmap = plt.get_cmap(\"viridis\")\n    color_dict = {\n        eval(miller): mpl.colors.rgb2hex(cmap(norm(value))[:3])\n        for miller, value in wulff_dict.items()\n    }\n\n    surf_energies = {\n        tuple(surface[\"MillerIndex\"]): float(surface[\"LowestSurfaceEnergy(J/m\u00b2)\"])\n        for surface in analysis[\"most_stable_by_miller\"]\n    }\n    bulk_structure = Structure.from_file(cif_file_path).to_ase_atoms()\n    particle = SingleCrystal(surf_energies, primitive_structure=bulk_structure)\n    fig, axes = plt.subplots(\n        nrows=plots[0],\n        ncols=plots[1],\n        subplot_kw={\"projection\": \"3d\"},\n        sharex=True,\n        sharey=True,\n        figsize=(figsize[0], figsize[1]),\n    )\n\n    if plots[0] == 1 and plots[1] == 1:\n        axes = np.array([axes])\n\n    for i in range(len(axes.flatten())):\n        if rotation:\n            axes.flatten()[i].view_init(rotation[i][0], rotation[i][1], rotation[i][2])\n        particle.make_plot(\n            axes.flatten()[i], colors=color_dict, linewidth=0.3, alpha=0.94\n        )\n\n    cbar = fig.colorbar(\n        mpl.cm.ScalarMappable(cmap=cmap, norm=norm), ax=axes.ravel().tolist()\n    )\n    cbar.ax.tick_params(labelsize=20)\n    ticks = np.linspace(vmin, vmax, 6)\n    cbar.set_ticks(ticks)\n    cbar.set_ticklabels([f\"{t:.1f}\" for t in ticks])\n    cbar.set_label(\"Percentage\", fontsize=30)\n    output_path = os.path.join(output_directory, \"percentage_plot.png\")\n    plt.savefig(output_path)\n    plt.close()\n</code></pre>"},{"location":"reference/wulfflow/processing/wulff_construction.html#wulfflow.processing.wulff_construction.create_color_dict","title":"create_color_dict","text":"<pre><code>create_color_dict(wulff_dict, cmap, normalize_surface=False)\n</code></pre> <p>Create a color dict based on miller indices, surfaces energies or atom presence.</p> <p>Parameters:</p> <ul> <li> <code>wulff_dict</code>               (<code>dict</code>)           \u2013            <p>Dictionary containing Wulff data.</p> </li> <li> <code>cmap</code>               (<code>Colormap</code>)           \u2013            <p>Colormap to use for coloring.</p> </li> <li> <code>normalize_surface</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to normalize the surface energies, by default False.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>           \u2013            <p>Dictionary mapping miller indices to colors.</p> </li> </ul> Source code in <code>wulfflow/processing/wulff_construction.py</code> <pre><code>def create_color_dict(wulff_dict, cmap, normalize_surface=False):\n    \"\"\"\n    Create a color dict based on miller indices, surfaces energies or atom presence.\n\n    Parameters\n    ----------\n    wulff_dict : dict\n        Dictionary containing Wulff data.\n    cmap : Colormap\n        Colormap to use for coloring.\n    normalize_surface : bool, optional\n        Whether to normalize the surface energies, by default False.\n\n    Returns\n    -------\n    dict\n        Dictionary mapping miller indices to colors.\n    \"\"\"\n    if normalize_surface:\n        norm = colors.Normalize(vmin=0, vmax=max(wulff_dict.values()))\n    else:\n        norm = colors.Normalize(\n            vmin=min(wulff_dict.values()), vmax=max(wulff_dict.values())\n        )\n\n    return {miller: cmap(norm(energy)) for miller, energy in wulff_dict.items()}\n</code></pre>"},{"location":"reference/wulfflow/processing/wulff_construction.html#wulfflow.processing.wulff_construction.histogram_plots","title":"histogram_plots","text":"<pre><code>histogram_plots(directory)\n</code></pre> <p>Generate histogram plots for depth analysis.</p> <p>Parameters:</p> <ul> <li> <code>directory</code>               (<code>str</code>)           \u2013            <p>Directory containing the Wulff data json file.</p> </li> </ul> Source code in <code>wulfflow/processing/wulff_construction.py</code> <pre><code>def histogram_plots(directory):\n    \"\"\"\n    Generate histogram plots for depth analysis.\n\n    Parameters\n    ----------\n    directory : str\n        Directory containing the Wulff data json file.\n    \"\"\"\n\n    with open(os.path.join(directory, \"wulff_data.json\")) as f:\n        data = json.load(f)\n\n    depth = data[\"depth\"]\n    unique = data[\"Elements\"]\n    per_element = {}\n    surfaces = []\n    for element in unique:\n        tmp = []\n        for surface in depth:\n            surfaces.append(surface)\n            tmp.append(depth[surface][element][0])\n            bins = depth[surface][element][1]\n            per_element[element] = tmp\n\n    nplot = len(unique)\n    fig, axes = plt.subplots(nplot, sharex=True)\n    non_zero_surfaces = [\n        i for i, (_, value) in enumerate(data[\"area_fraction\"].items()) if value != 0\n    ]\n    non_zero_surfaces.append(len(surfaces) - 1)\n    if nplot == 1:\n        axes = np.array([axes])\n    for j, ax in enumerate(axes.flat):\n        element_data = per_element[unique[j]]\n        for i in non_zero_surfaces:\n            ax.hist(element_data[i], bins=bins, alpha=0.5, label=surfaces[i])\n\n        ax.set_title(f\"Element: {unique[j]}\")\n        ax.legend()\n\n    plt.xlabel(\"Angstrom\")\n    plt.ylabel(\"Count\")\n    plt.grid(True)\n    plt.tight_layout()\n    output_path = os.path.join(directory, \"histogram_per_element.png\")\n    plt.savefig(output_path, dpi=300, bbox_inches=\"tight\")\n    plt.close()\n\n    # Plot 2\n    nplot = len(non_zero_surfaces)\n    surfaces = np.array(surfaces)[non_zero_surfaces].tolist()\n\n    fig, axes = plt.subplots(nplot, sharex=True, sharey=True, constrained_layout=True)\n    n_rows = int(np.ceil(np.sqrt(nplot)))\n    n_cols = int(np.ceil(nplot / n_rows))\n    fig.add_gridspec(n_rows, n_cols)\n    if nplot == 1:\n        axes = np.array([axes])\n    for j, ax in enumerate(axes.flat):\n        surface_data = depth[surfaces[j]]\n        for i in range(len(surface_data)):\n            ax.hist(surface_data[unique[i]][0], bins=bins, alpha=0.5, label=unique[i])\n\n        ax.set_title(surfaces[j])\n\n    ax.legend()\n    fig.supxlabel(\"Angstrom\")\n    fig.supylabel(\"Count\")\n    fig.set_size_inches(min(n_cols * 5, 20), min(n_rows * 4, 16))\n    output_path = os.path.join(directory, \"histogram_per_surface.png\")\n    plt.savefig(output_path, dpi=300, bbox_inches=\"tight\")\n    plt.close()\n</code></pre>"},{"location":"reference/wulfflow/processing/wulff_construction.html#wulfflow.processing.wulff_construction.make_wulff_construction","title":"make_wulff_construction","text":"<pre><code>make_wulff_construction(directory, analysis)\n</code></pre> <p>Generate a Wulff shape and json file with the related data.</p> <p>Parameters:</p> <ul> <li> <code>directory</code>               (<code>str</code>)           \u2013            <p>Path to the json files.</p> </li> <li> <code>analysis</code>               (<code>dict</code>)           \u2013            <p>Dictionary that includes the information about the slabs.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>WulffShape</code>           \u2013            <p>The generated Wulff shape.</p> </li> </ul> Source code in <code>wulfflow/processing/wulff_construction.py</code> <pre><code>def make_wulff_construction(directory: str, analysis: dict) -&gt; WulffShape:\n    \"\"\"\n    Generate a Wulff shape and json file with the related data.\n\n    Parameters\n    ----------\n    directory : str\n        Path to the json files.\n    analysis : dict\n        Dictionary that includes the information about the slabs.\n\n    Returns\n    -------\n    WulffShape\n        The generated Wulff shape.\n    \"\"\"\n\n    miller_list, energy_list, slab_atoms = get_energy_miller_atoms(analysis, directory)\n\n    bulk_structure = Structure.from_file(CIF_FILE_PATH)\n    wulff_shape = WulffShape(bulk_structure.lattice, miller_list, energy_list)\n\n    attribute_mapping = {\n        \"anisotropy\": \"anisotropy\",\n        \"area_fraction\": \"area_fraction_dict\",\n        \"effective_radius\": \"effective_radius\",\n        \"miller_area\": \"miller_area_dict\",\n        \"shape_factor\": \"shape_factor\",\n        \"surface_area\": \"surface_area\",\n        \"total_corner_sites\": \"tot_corner_sites\",\n        \"total_edges\": \"tot_edges\",\n        \"volume\": \"volume\",\n    }\n\n    wulff_data = {}\n    for key, attr in attribute_mapping.items():\n        try:\n            value = getattr(wulff_shape, attr)\n            if isinstance(value, dict):\n                converted_dict = {}\n                for k, v in value.items():\n                    new_key = str(k) if isinstance(k, tuple) else k\n                    converted_dict[new_key] = v\n                wulff_data[key] = converted_dict\n            else:\n                wulff_data[key] = value\n        except AttributeError:\n            print(f\"Warning: '{attr}' attribute not found in WulffShape instance\")\n            wulff_data[key] = None\n\n    wulff_data[\"coverage\"] = analyse_crystal_layers(directory, analysis)\n    wulff_data[\"depth\"] = analyse_depth(directory, analysis)\n    wulff_data[\"depth\"][\"average\"] = calculate_average_depth(wulff_data)\n    wulff_data[\"surface_energies\"] = {\n        \"\".join(str(miller_list[i])): energy_list[i] for i in range(len(energy_list))\n    }\n    wulff_data[\"Elements\"] = np.unique(\n        bulk_structure.to_ase_atoms().get_chemical_symbols()\n    ).tolist()\n    wulff_data[\"natoms\"] = {\n        \"\".join(str(miller_list[i])): len(slab_atoms[i])\n        for i in range(len(miller_list))\n    }\n    save_wulff_data_to_json(wulff_data)\n    return wulff_shape\n</code></pre>"},{"location":"reference/wulfflow/processing/wulff_construction.html#wulfflow.processing.wulff_construction.plot_wulff_shape","title":"plot_wulff_shape","text":"<pre><code>plot_wulff_shape(output_directory, analysis, cif_file_path=CIF_FILE_PATH, show_indices=True, show_surface_energies=True, plots=None, figsize=None, rotation=None)\n</code></pre> <p>Plot the Wulff shape.</p> <p>Parameters:</p> <ul> <li> <code>output_directory</code>               (<code>str</code>)           \u2013            <p>Directory to save the plot.</p> </li> <li> <code>analysis</code>               (<code>dict</code>)           \u2013            <p>Analysis data for plotting.</p> </li> <li> <code>cif_file_path</code>               (<code>str</code>, default:                   <code>CIF_FILE_PATH</code> )           \u2013            <p>Path to the CIF file, by default CIF_FILE_PATH.</p> </li> <li> <code>show_indices</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to show Miller indices, by default True.</p> </li> <li> <code>show_surface_energies</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to show surface energies, by default True.</p> </li> <li> <code>plots</code>               (<code>list</code>, default:                   <code>None</code> )           \u2013            <p>Plot grid dimensions, by default None.</p> </li> <li> <code>figsize</code>               (<code>list</code>, default:                   <code>None</code> )           \u2013            <p>Figure size, by default None.</p> </li> <li> <code>rotation</code>               (<code>list</code>, default:                   <code>None</code> )           \u2013            <p>Rotation angles, by default None.</p> </li> </ul> Source code in <code>wulfflow/processing/wulff_construction.py</code> <pre><code>def plot_wulff_shape(\n    output_directory,\n    analysis,\n    cif_file_path=CIF_FILE_PATH,\n    show_indices=True,\n    show_surface_energies=True,\n    plots=None,\n    figsize=None,\n    rotation=None,\n):\n    \"\"\"\n    Plot the Wulff shape.\n\n    Parameters\n    ----------\n    output_directory : str\n        Directory to save the plot.\n    analysis : dict\n        Analysis data for plotting.\n    cif_file_path : str, optional\n        Path to the CIF file, by default CIF_FILE_PATH.\n    show_indices : bool, optional\n        Whether to show Miller indices, by default True.\n    show_surface_energies : bool, optional\n        Whether to show surface energies, by default True.\n    plots : list, optional\n        Plot grid dimensions, by default None.\n    figsize : list, optional\n        Figure size, by default None.\n    rotation : list, optional\n        Rotation angles, by default None.\n    \"\"\"\n\n    if rotation is None:\n        rotation = [\n            (0, 0, 0),\n            (0, 45, 0),\n            (0, 90, 0),\n            (0, 135, 0),\n            (45, 0, 0),\n            (45, 45, 0),\n            (45, 90, 0),\n            (45, 135, 0),\n            (90, 0, 0),\n            (90, 45, 0),\n            (90, 90, 0),\n            (90, 135, 0),\n            (135, 0, 0),\n            (135, 45, 0),\n            (135, 90, 0),\n            (135, 135, 0),\n        ]\n    if figsize is None:\n        figsize = [15, 15]\n    if plots is None:\n        plots = [4, 4]\n    wulff_dict = {\n        tuple(surface[\"MillerIndex\"]): float(surface[\"LowestSurfaceEnergy(J/m\u00b2)\"])\n        for surface in analysis[\"most_stable_by_miller\"]\n    }\n    bulk_structure = Structure.from_file(cif_file_path).to_ase_atoms()\n    particle = SingleCrystal(wulff_dict, primitive_structure=bulk_structure)\n    fig, axes = plt.subplots(\n        nrows=plots[0],\n        ncols=plots[1],\n        subplot_kw={\"projection\": \"3d\"},\n        sharex=True,\n        sharey=True,\n        figsize=(figsize[0], figsize[1]),\n    )\n\n    if plots[0] == 1 and plots[1] == 1:\n        axes = np.array([axes])\n\n    cmap = plt.get_cmap(\"viridis\")\n\n    if show_indices or show_surface_energies:\n        normalize_surface = not show_indices\n        color_dict = create_color_dict(\n            wulff_dict, cmap, normalize_surface=normalize_surface\n        )\n\n    for i in range(len(axes.flatten())):\n        if rotation:\n            axes.flatten()[i].view_init(rotation[i][0], rotation[i][1], rotation[i][2])\n        particle.make_plot(\n            axes.flatten()[i], colors=color_dict, linewidth=0.3, alpha=0.94\n        )\n\n    if show_indices:\n        legend_elements = [\n            plt.Rectangle(\n                (0, 0), 1, 1, facecolor=color_dict[miller], edgecolor=\"none\", alpha=0.94\n            )\n            for miller in wulff_dict\n        ]\n        legend_labels = [\n            f\"({miller[0]}{miller[1]}{miller[2]})\" for miller in wulff_dict\n        ]\n\n        legend = axes.flatten()[-1].legend(\n            legend_elements,\n            legend_labels,\n            loc=\"upper center\",\n            bbox_to_anchor=(0.5, 1),\n            bbox_transform=fig.transFigure,\n            ncol=9,\n            frameon=True,\n            edgecolor=\"black\",\n            fontsize=15,\n            handlelength=1.8,\n            handleheight=0.8,\n            borderpad=0.5,\n            labelspacing=0.8,\n        )\n        legend.set_title(\"Miller Indices\", prop={\"size\": 20, \"weight\": \"bold\"})\n\n    elif show_surface_energies:\n        vmin, vmax = min(wulff_dict.values()), max(wulff_dict.values())\n        norm = colors.Normalize(vmin=vmin, vmax=vmax)\n        cbar = fig.colorbar(\n            mpl.cm.ScalarMappable(cmap=cmap, norm=norm), ax=axes.ravel().tolist()\n        )\n        cbar.ax.tick_params(labelsize=20)\n        ticks = np.linspace(vmin, vmax, 6)\n        cbar.set_ticks(ticks)\n        cbar.set_ticklabels([f\"{t:.1f}\" for t in ticks])\n        cbar.set_label(\"Surface Energies ($J/m^2$)\", fontsize=30)\n\n    output_path = os.path.join(output_directory, \"wulff_shape.png\")\n    plt.savefig(output_path)\n    plt.close()\n</code></pre>"},{"location":"reference/wulfflow/utils/chempot.html","title":"chempot","text":""},{"location":"reference/wulfflow/utils/chempot.html#wulfflow.utils.chempot.find_best_chem_pots_from_json","title":"find_best_chem_pots_from_json","text":"<pre><code>find_best_chem_pots_from_json(directory, use_literature_value=True, temperature=298.15, oxide=True)\n</code></pre> <p>Find the best chemical potentials from JSON files in the given directory.</p> <p>Parameters:</p> <ul> <li> <code>directory</code>               (<code>str</code>)           \u2013            <p>Path to the directory containing JSON files.</p> </li> <li> <code>use_literature_value</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Use literature value for O2 chemical potential if True. Defaults to True.</p> </li> <li> <code>temperature</code>               (<code>float</code>, default:                   <code>298.15</code> )           \u2013            <p>Temperature for chemical potential calculation in Kelvin. Defaults to 298.15.</p> </li> <li> <code>oxide</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to include oxygen in calculations. Defaults to True.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, float]</code>           \u2013            <p>Dictionary of best chemical potentials for each element.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If no bulk structure is found in references.json.</p> </li> </ul> Source code in <code>wulfflow/utils/chempot.py</code> <pre><code>def find_best_chem_pots_from_json(\n    directory: str,\n    use_literature_value: bool = True,\n    temperature: float = 298.15,\n    oxide: bool = True,\n) -&gt; dict[str, float]:\n    \"\"\"\n    Find the best chemical potentials from JSON files in the given directory.\n\n    Parameters\n    ----------\n    directory : str\n        Path to the directory containing JSON files.\n    use_literature_value : bool, optional\n        Use literature value for O2 chemical potential if True. Defaults to True.\n    temperature : float, optional\n        Temperature for chemical potential calculation in Kelvin. Defaults to 298.15.\n    oxide : bool, optional\n        Whether to include oxygen in calculations. Defaults to True.\n\n    Returns\n    -------\n    dict[str, float]\n        Dictionary of best chemical potentials for each element.\n\n    Raises\n    ------\n    ValueError\n        If no bulk structure is found in references.json.\n    \"\"\"\n\n    def load_json(filename: str) -&gt; dict:\n        with open(os.path.join(directory, filename)) as f:\n            return json.load(f)\n\n    references_data = load_json(\"references.json\")\n    elements_data = load_json(\"elements.json\")\n    oxides_data = load_json(\"oxides.json\") if oxide else {}\n\n    bulk_entry = next(\n        (entry for entry in references_data if entry[\"label\"] != \"O2\"), None\n    )\n    if bulk_entry is None:\n        raise ValueError(\"No bulk structure found in references.json\")\n\n    bulk_formula = bulk_entry[\"label\"]\n    bulk_atoms = json_to_atoms(os.path.join(directory, \"references.json\"), bulk_formula)\n    bulk_energy = bulk_atoms.info[\"energy\"]\n    bulk_atom_count = find_element_numbers(bulk_atoms)\n\n    element_chem_pots = {\n        element[\"label\"]: json_to_atoms(\n            os.path.join(directory, \"elements.json\"), element[\"label\"]\n        ).info[\"energy\"]\n        / len(json_to_atoms(os.path.join(directory, \"elements.json\"), element[\"label\"]))\n        for element in elements_data\n    }\n\n    if oxide:\n        try:\n            o2_atoms = json_to_atoms(os.path.join(directory, \"references.json\"), \"O2\")\n            o2_energy = o2_atoms.info[\"energy\"]\n\n            if use_literature_value:\n                o2_entropic_t_gradient = 0.002126230462345  # eV.K^(-1)\n                o_chem_pot = (o2_energy - (o2_entropic_t_gradient * temperature)) / 2\n            else:\n                results = {\"references\": {1: {\"O2\": o2_atoms}}}\n                o_chem_pot = get_molecular_oxygen_chem_pot(\n                    results, use_literature_value, temperature\n                )\n\n            element_chem_pots[\"O\"] = o_chem_pot\n        except ValueError:\n            print(\n                \"O2 not found in references. Skipping oxygen chemical potential calculation.\"\n            )\n\n    oxide_chem_pots = {}\n    for oxide in oxides_data:\n        oxide_atoms = json_to_atoms(\n            os.path.join(directory, \"oxides.json\"), oxide[\"label\"]\n        )\n        atom_count = find_element_numbers(oxide_atoms)\n        non_O_element = next(element for element in atom_count if element != \"O\")\n        oxide_chem_pot = (\n            oxide_atoms.info[\"energy\"] - atom_count[\"O\"] * element_chem_pots.get(\"O\", 0)\n        ) / atom_count[non_O_element]\n        oxide_chem_pots[f\"{non_O_element}_{oxide['label']}\"] = oxide_chem_pot\n\n    all_chem_pots = {**element_chem_pots, **oxide_chem_pots}\n\n    best_chem_pots = {\"O\": element_chem_pots.get(\"O\", 0)} if oxide else {}\n    non_o_elements = [elem for elem in bulk_atom_count if elem != \"O\"]\n\n    best_score = float(\"inf\")\n    best_combination = None\n\n    for combination in itertools.product(\n        *[all_chem_pots.keys() for _ in non_o_elements]\n    ):\n        chem_pot_energy = sum(\n            bulk_atom_count[element] * all_chem_pots[chem_pot]\n            for element, chem_pot in zip(non_o_elements, combination, strict=False)\n        ) + bulk_atom_count.get(\"O\", 0) * element_chem_pots.get(\"O\", 0)\n\n        score = abs(bulk_energy - chem_pot_energy)\n        if score &lt; best_score:\n            best_score = score\n            best_combination = combination\n\n    for element, chem_pot in zip(non_o_elements, best_combination, strict=False):\n        best_chem_pots[element] = all_chem_pots[chem_pot]\n\n    return best_chem_pots\n</code></pre>"},{"location":"reference/wulfflow/utils/chempot.html#wulfflow.utils.chempot.get_molecular_oxygen_chem_pot","title":"get_molecular_oxygen_chem_pot","text":"<pre><code>get_molecular_oxygen_chem_pot(results, use_literature_value=True, temperature=298.15)\n</code></pre> <p>Calculates the chemical potential of an atom of molecular oxygen.</p> <p>Parameters:</p> <ul> <li> <code>results</code>               (<code>dict[str, tuple[dict[str, Atoms], Any]]</code>)           \u2013            <p>Dictionary of tuples generated from the main workflow.</p> </li> <li> <code>use_literature_value</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Use the literature value for the entropic gradient of O2 if True. Defaults to True.</p> </li> <li> <code>temperature</code>               (<code>float</code>, default:                   <code>298.15</code> )           \u2013            <p>Temperature at which chem pot is calculated in Kelvin. Defaults to 298.15.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>Value of the chemical potential of O for a given temperature.</p> </li> </ul> Source code in <code>wulfflow/utils/chempot.py</code> <pre><code>def get_molecular_oxygen_chem_pot(\n    results: dict[str, tuple[dict[str, Atoms], Any]],\n    use_literature_value: bool = True,\n    temperature: float = 298.15,\n) -&gt; float:\n    \"\"\"\n    Calculates the chemical potential of an atom of molecular oxygen.\n\n    Parameters\n    ----------\n    results : dict[str, tuple[dict[str, Atoms], Any]]\n        Dictionary of tuples generated from the main workflow.\n    use_literature_value : bool, optional\n        Use the literature value for the entropic gradient of O2 if True. Defaults to True.\n    temperature : float, optional\n        Temperature at which chem pot is calculated in Kelvin. Defaults to 298.15.\n\n    Returns\n    -------\n    float\n        Value of the chemical potential of O for a given temperature.\n    \"\"\"\n    o2_energy = results[\"references\"][1][\"O2\"].info[\"energy\"]\n\n    if use_literature_value:\n        o2_entropic_t_gradient = 0.00212625119  # eV.K^(-1) https://webbook.nist.gov/cgi/cbook.cgi?ID=C7782447&amp;Mask=1\n    else:\n        # Constants\n        pressure = 101325  # Pa\n        hj = 6.626076e-034  # joules.s\n        kbj = 1.38066e-023  # Boltzmann constant J.K^(-1)\n        j2ev = 6.241509074461e18  # conversion factor of J to eV\n        o2_mass = 5.31384921952838e-26  # kg\n        o2_bond_length = (\n            results[\"references\"][1][\"O2\"].get_all_distances()[0][1] * 1e-10\n        )  # taken from calc or use 1.2075e-10 for lit value\n        vibrational_freq = 1580.36  # cm^(-1), characteristic vibration of O2\n\n        # derived variables\n        hbarj = hj / (2 * np.pi)\n        volume = (kbj * temperature) / pressure\n        impulse = (o2_mass / 2) * o2_bond_length**2\n        hcB = hbarj**2 / (2 * impulse)\n\n        # entropy of single O2 molecule derived from differentiating parition funcitons by ln(T)\n        # translational entropy\n        s_trans = kbj * (\n            np.log((2 * np.pi * o2_mass * kbj * temperature) / hj**2) ** (3 / 2)\n            + np.log(volume)\n            + 5 / 2\n        )\n\n        # vibrational entropy\n        s_vib = kbj * (\n            -np.log(1 - np.exp(-(hj * vibrational_freq) / (kbj * temperature)))\n            + (\n                (hj * vibrational_freq)\n                / (kbj * temperature)\n                * (\n                    np.exp(-(hj * vibrational_freq) / (kbj * temperature))\n                    / (1 - np.exp(-(hj * vibrational_freq) / (kbj * temperature)))\n                )\n            )\n        )\n\n        # rotational entropy\n        s_rot = kbj * (np.log((kbj * temperature) / 2 * hcB) + 1)\n\n        s = np.sum([s_trans, s_vib, s_rot])\n\n        o2_entropy = (s + kbj * temperature * np.log(pressure / 101325)) * j2ev\n\n    o_chem_pot_value = (o2_energy - (o2_entropy * temperature)) / 2\n    return True\n    return o_chem_pot_value\n</code></pre>"},{"location":"reference/wulfflow/utils/config.html","title":"config","text":""},{"location":"reference/wulfflow/utils/config.html#wulfflow.utils.config.create_command","title":"create_command","text":"<pre><code>create_command(nodes_per_block, tasks, ndiag=None, ntg=None)\n</code></pre> <p>Create the command for running the job.</p> <p>Parameters:</p> <ul> <li> <code>nodes_per_block</code>               (<code>int</code>)           \u2013            <p>Number of nodes per block.</p> </li> <li> <code>tasks</code>               (<code>int</code>)           \u2013            <p>Number of tasks.</p> </li> <li> <code>ndiag</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>Number of diagonal tasks, by default None.</p> </li> <li> <code>ntg</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>Number of task groups, by default None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[str, str]</code>           \u2013            <p>Pre and post binary commands.</p> </li> </ul> Source code in <code>wulfflow/utils/config.py</code> <pre><code>def create_command(\n    nodes_per_block: int, tasks: int, ndiag: int | None = None, ntg: int | None = None\n) -&gt; tuple[str, str]:\n    \"\"\"\n    Create the command for running the job.\n\n    Parameters\n    ----------\n    nodes_per_block : int\n        Number of nodes per block.\n    tasks : int\n        Number of tasks.\n    ndiag : int, optional\n        Number of diagonal tasks, by default None.\n    ntg : int, optional\n        Number of task groups, by default None.\n\n    Returns\n    -------\n    tuple[str, str]\n        Pre and post binary commands.\n    \"\"\"\n    nodes_per_task = nodes_per_block\n    ranks_per_node = (\n        COMMON_PARAMS[\"cores_per_node\"] // COMMON_PARAMS[\"threads_per_process\"]\n    )\n    total_ranks = nodes_per_task * ranks_per_node\n\n    pre_binary = (\n        f\"srun --mpi=pmix \"\n        f\"--nodes={nodes_per_task} \"\n        f\"--ntasks={total_ranks} \"\n        f\"--ntasks-per-node={ranks_per_node} \"\n        f\"--cpus-per-task={COMMON_PARAMS['threads_per_process']}\"\n    )\n\n    post_binary = \"\"\n    if ntg:\n        post_binary += f\" -ntg {ntg}\"\n    if ndiag:\n        post_binary += f\" -ndiag {ndiag}\"\n\n    return pre_binary, post_binary.strip()\n</code></pre>"},{"location":"reference/wulfflow/utils/config.html#wulfflow.utils.config.create_executor","title":"create_executor","text":"<pre><code>create_executor(label, nodes_per_block, max_blocks)\n</code></pre> <p>Create a HighThroughputExecutor.</p> <p>Parameters:</p> <ul> <li> <code>label</code>               (<code>str</code>)           \u2013            <p>Label for the executor.</p> </li> <li> <code>nodes_per_block</code>               (<code>int</code>)           \u2013            <p>Number of nodes per block.</p> </li> <li> <code>max_blocks</code>               (<code>int</code>)           \u2013            <p>Maximum number of blocks.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>HighThroughputExecutor</code>           \u2013            <p>The created executor.</p> </li> </ul> Source code in <code>wulfflow/utils/config.py</code> <pre><code>def create_executor(\n    label: str, nodes_per_block: int, max_blocks: int\n) -&gt; HighThroughputExecutor:\n    \"\"\"\n    Create a HighThroughputExecutor.\n\n    Parameters\n    ----------\n    label : str\n        Label for the executor.\n    nodes_per_block : int\n        Number of nodes per block.\n    max_blocks : int\n        Maximum number of blocks.\n\n    Returns\n    -------\n    HighThroughputExecutor\n        The created executor.\n    \"\"\"\n    return HighThroughputExecutor(\n        label=label,\n        max_workers_per_node=1,\n        cores_per_worker=1.0e-6,\n        provider=SlurmProvider(\n            cores_per_node=COMMON_PARAMS[\"threads_per_process\"],\n            partition=COMMON_PARAMS[\"partition\"],\n            account=COMMON_PARAMS[\"account\"],\n            walltime=\"60:00:00\",\n            nodes_per_block=nodes_per_block,\n            init_blocks=1,\n            min_blocks=0,\n            max_blocks=max_blocks,\n            launcher=SimpleLauncher(),\n            worker_init=create_worker_init(create_command(nodes_per_block, 1)[0]),\n        ),\n    )\n</code></pre>"},{"location":"reference/wulfflow/utils/config.html#wulfflow.utils.config.create_relax_job","title":"create_relax_job","text":"<pre><code>create_relax_job(label, nodes_per_block, max_blocks, ndiag=None, ntg=None)\n</code></pre> <p>Create a relaxation job.</p> <p>Parameters:</p> <ul> <li> <code>label</code>               (<code>str</code>)           \u2013            <p>Label for the job.</p> </li> <li> <code>nodes_per_block</code>               (<code>int</code>)           \u2013            <p>Number of nodes per block.</p> </li> <li> <code>max_blocks</code>               (<code>int</code>)           \u2013            <p>Maximum number of blocks.</p> </li> <li> <code>ndiag</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>Number of diagonal tasks, by default None.</p> </li> <li> <code>ntg</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>Number of task groups, by default None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple</code>           \u2013            <p>Executor and decorated job.</p> </li> </ul> Source code in <code>wulfflow/utils/config.py</code> <pre><code>def create_relax_job(\n    label: str,\n    nodes_per_block: int,\n    max_blocks: int,\n    ndiag: int | None = None,\n    ntg: int | None = None,\n):\n    \"\"\"\n    Create a relaxation job.\n\n    Parameters\n    ----------\n    label : str\n        Label for the job.\n    nodes_per_block : int\n        Number of nodes per block.\n    max_blocks : int\n        Maximum number of blocks.\n    ndiag : int, optional\n        Number of diagonal tasks, by default None.\n    ntg : int, optional\n        Number of task groups, by default None.\n\n    Returns\n    -------\n    tuple\n        Executor and decorated job.\n    \"\"\"\n    executor = create_executor(label, nodes_per_block, max_blocks)\n    pre_cmd, post_cmd = create_command(nodes_per_block, 1, ndiag=ndiag, ntg=ntg)\n\n    decorated_job = redecorate(\n        relax_job,\n        job(\n            executors=[label],\n            cache=True,\n            settings_swap={\n                \"RESTART_MODE\": True,\n                \"ESPRESSO_PARALLEL_CMD\": [pre_cmd, post_cmd] if post_cmd else pre_cmd,\n            },\n        ),\n    )\n    return executor, decorated_job\n</code></pre>"},{"location":"reference/wulfflow/utils/config.html#wulfflow.utils.config.create_worker_init","title":"create_worker_init","text":"<pre><code>create_worker_init(command)\n</code></pre> <p>Create the worker initialization script.</p> <p>Parameters:</p> <ul> <li> <code>command</code>               (<code>str</code>)           \u2013            <p>Command to initialize the worker.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>Worker initialization script.</p> </li> </ul> Source code in <code>wulfflow/utils/config.py</code> <pre><code>def create_worker_init(command: str) -&gt; str:\n    \"\"\"\n    Create the worker initialization script.\n\n    Parameters\n    ----------\n    command : str\n        Command to initialize the worker.\n\n    Returns\n    -------\n    str\n        Worker initialization script.\n    \"\"\"\n    return \"\"\"\nsource /iridisfs/home/ba3g18/.bashrc\nconda activate Quacc_restarts\n\nmodule purge\nmodule load pmix\nmodule load binutils/2.42\nmodule load intel-mpi/2021.12\nmodule load mkl/2024.1.0\nmodule load intel-compilers/2024.1.0\n\nexport OMP_PLACES=cores\nexport OMP_NUM_THREADS=1\nexport MKL_NUM_THREADS=1\nexport MKL_DYNAMIC=FALSE\nexport OMP_PROC_BIND=close\nexport I_MPI_FABRICS=shm:ofi\nexport I_MPI_COLL_INTRANODE=shm\nexport I_MPI_ADJUST_ALLGATHERV=1\nexport MKL_THREADING_LAYER=sequential\nexport ESPRESSO_PSEUDO=\"/home/ba3g18/Repos/SSSP_1.3.0_PBE_efficiency\"\nexport I_MPI_PMI_LIBRARY=/iridisfs/i6software/slurm/24.05.1/lib/libpmi.so\n\"\"\"\n</code></pre>"},{"location":"reference/wulfflow/utils/config.html#wulfflow.utils.config.hash_dict","title":"hash_dict","text":"<pre><code>hash_dict(d, exclude_keys=None)\n</code></pre> <p>Hash a dictionary.</p> <p>Parameters:</p> <ul> <li> <code>d</code>               (<code>dict</code>)           \u2013            <p>Dictionary to hash.</p> </li> <li> <code>exclude_keys</code>               (<code>list[str]</code>, default:                   <code>None</code> )           \u2013            <p>Keys to exclude from hashing, by default None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bytes</code>           \u2013            <p>Hash of the dictionary.</p> </li> </ul> Source code in <code>wulfflow/utils/config.py</code> <pre><code>def hash_dict(d, exclude_keys: list[str] | None = None) -&gt; bytes:\n    \"\"\"\n    Hash a dictionary.\n\n    Parameters\n    ----------\n    d : dict\n        Dictionary to hash.\n    exclude_keys : list[str], optional\n        Keys to exclude from hashing, by default None.\n\n    Returns\n    -------\n    bytes\n        Hash of the dictionary.\n    \"\"\"\n    if exclude_keys is None:\n        exclude_keys = []\n\n    for key in exclude_keys:\n        d = remove_dict_keys(d, key)\n\n    json_str = json.dumps(d, sort_keys=True)\n    return hashlib.md5(json_str.encode(\"utf-8\")).digest()\n</code></pre>"},{"location":"reference/wulfflow/utils/constants.html","title":"constants","text":""},{"location":"reference/wulfflow/utils/utils.html","title":"utils","text":""},{"location":"reference/wulfflow/utils/utils.html#wulfflow.utils.utils.analyse_crystal_layers","title":"analyse_crystal_layers","text":"<pre><code>analyse_crystal_layers(directory, analysis)\n</code></pre> <p>Analyze the composition of crystal layers for given Miller indices.</p> <p>Args:     directory: Path to the json files     analysis: dictionary that includes the information about the slabs</p> <p>Returns:     Dictionary containing layer-wise composition for each Miller index</p> Source code in <code>wulfflow/utils/utils.py</code> <pre><code>def analyse_crystal_layers(\n    directory: str, analysis: dict\n) -&gt; dict[str, dict[int, list[tuple[str, float]]]]:\n    \"\"\"\n    Analyze the composition of crystal layers for given Miller indices.\n\n    Args:\n        directory: Path to the json files\n        analysis: dictionary that includes the information about the slabs\n\n    Returns:\n        Dictionary containing layer-wise composition for each Miller index\n    \"\"\"\n    miller_list, _, slab_atoms = get_energy_miller_atoms(analysis, directory)\n    data = {}\n\n    for i in range(len(slab_atoms)):\n        layers, _ = get_layers(slab_atoms[i], miller_list[i])\n        layer_compositions = analyse_layer_composition(slab_atoms[i], layers)\n\n        miller_key = \"\".join(str(miller_list[i]))\n        data[miller_key] = layer_compositions\n\n    return data\n</code></pre>"},{"location":"reference/wulfflow/utils/utils.html#wulfflow.utils.utils.analyse_depth","title":"analyse_depth","text":"<pre><code>analyse_depth(directory, analysis, bins=10, range_values=None)\n</code></pre> <p>Analyze the composition along z of the crystal surface.</p> <p>Args:     directory: Path to the json files     analysis: dictionary that includes the information about the slabs</p> <p>Returns:     Dictionary containing layer-wise composition for each Miller index</p> Source code in <code>wulfflow/utils/utils.py</code> <pre><code>def analyse_depth(\n    directory: str, analysis: dict, bins=10, range_values=None\n) -&gt; dict[str, dict[int, list[tuple[str, float]]]]:\n    \"\"\"\n    Analyze the composition along z of the crystal surface.\n\n    Args:\n        directory: Path to the json files\n        analysis: dictionary that includes the information about the slabs\n\n    Returns:\n        Dictionary containing layer-wise composition for each Miller index\n    \"\"\"\n    if range_values is None:\n        range_values = [0, 50]\n    miller_list, _, slab_atoms = get_energy_miller_atoms(analysis, directory)\n    data = {}\n    for i in range(len(slab_atoms)):\n        histogram = {}\n        unique = np.unique(slab_atoms[i].get_chemical_symbols())\n        for element in unique:\n            histo = np.histogram(\n                slab_atoms[i].get_positions()[\n                    np.where(np.array(slab_atoms[i].get_chemical_symbols()) == element)\n                ][:, 2],\n                bins=bins,\n                range=range_values,\n            )\n            histogram[element] = [x.tolist() for x in histo]\n        miller_key = \"\".join(str(miller_list[i]))\n        data[miller_key] = histogram\n\n    return data\n</code></pre>"},{"location":"reference/wulfflow/utils/utils.html#wulfflow.utils.utils.analyse_layer_composition","title":"analyse_layer_composition","text":"<pre><code>analyse_layer_composition(structure_file, layers, num_layers=1)\n</code></pre> <p>Analyse chemical composition of each layer in the crystal.</p> <p>Args:     structure_file: ASE Atoms object containing crystal structure     layers: Array containing layer assignments     num_layers: Number of layers to analyse</p> <p>Returns:     Dictionary containing composition ratios for each layer,     sorted by ratio in descending order</p> Source code in <code>wulfflow/utils/utils.py</code> <pre><code>def analyse_layer_composition(\n    structure_file: Atoms, layers: np.ndarray, num_layers: int = 1\n) -&gt; dict[int, list[tuple[str, float]]]:\n    \"\"\"\n    Analyse chemical composition of each layer in the crystal.\n\n    Args:\n        structure_file: ASE Atoms object containing crystal structure\n        layers: Array containing layer assignments\n        num_layers: Number of layers to analyse\n\n    Returns:\n        Dictionary containing composition ratios for each layer,\n        sorted by ratio in descending order\n    \"\"\"\n    layer_compositions = {}\n\n    for layer_idx in range(num_layers):\n        layer_atoms = np.where(layers == layer_idx + 1)[0]\n        unique_elements, counts = zip(\n            *find_element_numbers(structure_file[layer_atoms]).items(), strict=False\n        )\n        all_elements = structure_file.get_chemical_symbols()\n        for element in all_elements:\n            if element not in unique_elements:\n                unique_elements = np.append(unique_elements, element)\n                counts = np.append(counts, 0)\n        total_atoms = np.sum(counts)\n\n        if total_atoms == 0:\n            composition = [(element, 0) for element in unique_elements]\n        else:\n            composition = [\n                (element, count / total_atoms)\n                for element, count in zip(unique_elements, counts, strict=False)\n            ]\n\n        composition.sort(key=lambda x: x[1], reverse=True)\n        composition.append((\"Total\", int(total_atoms)))\n        layer_compositions[layer_idx] = composition\n    return layer_compositions\n</code></pre>"},{"location":"reference/wulfflow/utils/utils.html#wulfflow.utils.utils.calculate_average_depth","title":"calculate_average_depth","text":"<pre><code>calculate_average_depth(data)\n</code></pre> <p>Calculate the weighted average depth values across all surfaces for each element.</p> <p>Args:     data (dict): The input JSON data containing depth information</p> <p>Returns:     dict: A dictionary containing average depth values for each element</p> Source code in <code>wulfflow/utils/utils.py</code> <pre><code>def calculate_average_depth(data):\n    \"\"\"\n    Calculate the weighted average depth values across all surfaces for each element.\n\n    Args:\n        data (dict): The input JSON data containing depth information\n\n    Returns:\n        dict: A dictionary containing average depth values for each element\n    \"\"\"\n    depth_data = data[\"depth\"]\n    weights = data[\"area_fraction\"]\n\n    element_values = {}\n    element_weights = {}\n\n    for surface, elements in depth_data.items():\n        for element, (values, bins) in elements.items():\n            if element not in element_values:\n                element_values[element] = []\n                element_weights[element] = []\n            element_values[element].append(values)\n            element_weights[element].append(weights[surface])\n\n    averages = {}\n    for element, value_lists in element_values.items():\n        value_array = np.array(value_lists)\n        weight_array = np.array(element_weights[element])\n        normalized_weights = weight_array / np.sum(weight_array)\n        average = np.sum(\n            value_array * normalized_weights[:, np.newaxis], axis=0\n        ).tolist()\n        averages[element] = average\n\n    first_surface = next(iter(depth_data.keys()))\n    first_element = next(iter(depth_data[first_surface].keys()))\n    bins = depth_data[first_surface][first_element][1]\n    return {element: [values, bins] for element, values in averages.items()}\n</code></pre>"},{"location":"reference/wulfflow/utils/utils.html#wulfflow.utils.utils.get_energy_miller_atoms","title":"get_energy_miller_atoms","text":"<pre><code>get_energy_miller_atoms(analysis, directory)\n</code></pre> <p>Get miller indices, surface energies, and slab atoms from analysis data for the slabs used in constructing the wulff shape.</p> <p>Args:     analysis: dictionary that includes the information about the slabs     directory: Path to the json files</p> <p>Returns:     Tuple of lists of miller indices, surface energies and slab atoms.</p> Source code in <code>wulfflow/utils/utils.py</code> <pre><code>def get_energy_miller_atoms(analysis: dict, directory: str) -&gt; tuple[list, list, list]:\n    \"\"\"\n    Get miller indices, surface energies, and slab atoms from analysis data for the slabs used\n    in constructing the wulff shape.\n\n    Args:\n        analysis: dictionary that includes the information about the slabs\n        directory: Path to the json files\n\n    Returns:\n        Tuple of lists of miller indices, surface energies and slab atoms.\n\n    \"\"\"\n    with open(os.path.join(directory, \"slabs.json\")) as f:\n        slabs_data = json.load(f)\n\n    miller_list = []\n    energy_list = []\n    slab_atoms_list = []\n\n    for surface in analysis[\"most_stable_by_miller\"]:\n        slab_name = surface[\"MostStableSlabName\"]\n        miller_tuple = tuple(surface[\"MillerIndex\"])\n        energy = float(surface[\"LowestSurfaceEnergy(J/m\u00b2)\"])\n\n        for slab in slabs_data:\n            if slab[\"label\"] == slab_name:\n                slab_atoms = json_to_atoms(\n                    os.path.join(directory, \"slabs.json\"), slab[\"label\"]\n                )\n                slab_atoms_list.append(slab_atoms)\n                break\n\n        miller_list.append(miller_tuple)\n        energy_list.append(energy)\n    return miller_list, energy_list, slab_atoms_list\n</code></pre>"},{"location":"reference/wulfflow/utils/utils.html#wulfflow.utils.utils.read_existing_slabs","title":"read_existing_slabs","text":"<pre><code>read_existing_slabs(slab_dir='slabs', spin=True)\n</code></pre> <p>Read existing slab structures from a directory.</p> <p>Parameters:</p> <ul> <li> <code>slab_dir</code>               (<code>str</code>, default:                   <code>'slabs'</code> )           \u2013            <p>Directory containing slab structure files</p> </li> <li> <code>spin</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to set initial magnetic moments on slabs</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Optional[Dict[str, Atoms]]</code>           \u2013            <p>Dictionary of slab structures if directory exists and contains files, None otherwise</p> </li> </ul> Source code in <code>wulfflow/utils/utils.py</code> <pre><code>def read_existing_slabs(\n    slab_dir: str = \"slabs\", spin: bool = True\n) -&gt; dict[str, Atoms] | None:\n    \"\"\"\n    Read existing slab structures from a directory.\n\n    Parameters\n    ----------\n    slab_dir : str\n        Directory containing slab structure files\n    spin : bool\n        Whether to set initial magnetic moments on slabs\n\n    Returns\n    -------\n    Optional[Dict[str, Atoms]]\n        Dictionary of slab structures if directory exists and contains files,\n        None otherwise\n    \"\"\"\n    slab_path = Path(slab_dir)\n    if not slab_path.exists() or not slab_path.is_dir():\n        print(f\"Slab directory '{slab_dir}' not found\")\n        return None\n\n    slab_files = list(slab_path.glob(\"*.xyz\"))\n    if not slab_files:\n        print(f\"No .xyz files found in '{slab_dir}'\")\n        return None\n\n    slabs = {}\n    for slab_file in slab_files:\n        try:\n            atoms = read(slab_file)\n            if spin:\n                atoms.set_initial_magnetic_moments([0.1] * len(atoms))\n            slabs[slab_file.stem] = atoms\n        except Exception as e:\n            print(f\"Error reading {slab_file}: {e}\")\n            continue\n\n    if not slabs:\n        print(\"No valid slab structures could be read\")\n        return None\n\n    print(f\"Successfully read {len(slabs)} slab structures from {slab_dir}\")\n    return slabs\n</code></pre>"},{"location":"reference/wulfflow/workflow/core.html","title":"core","text":""},{"location":"reference/wulfflow/workflow/core.html#wulfflow.workflow.core.main","title":"main","text":"<pre><code>main(spin=False, oxide=True, slabgen=True, run_bulk=True, perform_calculations=True)\n</code></pre> <p>Main function to run the complete workflow.</p> <p>Parameters:</p> <ul> <li> <code>spin</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to include spin polarization for slabs.</p> </li> <li> <code>perform_calculations</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to perform calculations or just analysis.</p> </li> <li> <code>oxide</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to include oxide calculations.</p> </li> <li> <code>slabgen</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to generate slab structures.</p> </li> <li> <code>run_bulk</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to run bulk calculations.</p> </li> </ul> Source code in <code>wulfflow/workflow/core.py</code> <pre><code>def main(\n    spin: bool = False,\n    oxide: bool = True,\n    slabgen: bool = True,\n    run_bulk: bool = True,\n    perform_calculations: bool = True,\n):\n    \"\"\"\n    Main function to run the complete workflow.\n\n    Parameters\n    ----------\n    spin : bool\n        Whether to include spin polarization for slabs.\n    perform_calculations : bool\n        Whether to perform calculations or just analysis.\n    oxide : bool\n        Whether to include oxide calculations.\n    slabgen : bool\n        Whether to generate slab structures.\n    run_bulk : bool\n        Whether to run bulk calculations.\n    \"\"\"\n    directory = os.getcwd()\n    slabs = None\n    if slabgen:\n        slabs = generate_slabs(CIF_FILE_PATH, write_xyzs=True)\n    else:\n        slabs = read_existing_slabs(spin=spin)\n\n    if perform_calculations:\n        parsl.load(config)\n        try:\n            results = main_workflow(oxide=oxide, slabs=slabs, run_bulk=run_bulk)\n            save_results(results)\n        finally:\n            parsl.dfk().cleanup()\n            parsl.clear()\n\n    chem_pots = find_best_chem_pots_from_json(directory, oxide=oxide)\n    surface_energies = calculate_surface_energies_from_json(\n        directory, chem_pots, oxide=oxide\n    )\n    analysis = analyse_surface_energies(surface_energies)\n    make_wulff_construction(directory, analysis)\n    plot_wulff_shape(directory, analysis, plots=[4, 4], figsize=[15, 15])\n    coverage_plot(directory, analysis)\n    histogram_plots(directory)\n    save_surface_energies_to_json(surface_energies)\n</code></pre>"},{"location":"reference/wulfflow/workflow/core.html#wulfflow.workflow.core.main_workflow","title":"main_workflow","text":"<pre><code>main_workflow(oxide=True, slabs=None, run_bulk=True)\n</code></pre> <p>Main workflow for running calculations.</p> <p>Parameters:</p> <ul> <li> <code>oxide</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to include oxide calculations.</p> </li> <li> <code>slabs</code>               (<code>dict[str, Atoms]</code>, default:                   <code>None</code> )           \u2013            <p>Dictionary of slab structures to calculate.</p> </li> <li> <code>run_bulk</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to run bulk calculations.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, tuple[dict[str, Atoms], Any]]</code>           \u2013            <p>Results dictionary containing structures and calculation results.</p> </li> </ul> Source code in <code>wulfflow/workflow/core.py</code> <pre><code>@flow\ndef main_workflow(\n    oxide: bool = True, slabs: dict[str, Atoms] | None = None, run_bulk: bool = True\n) -&gt; dict[str, tuple[dict[str, Atoms], Any]]:\n    \"\"\"\n    Main workflow for running calculations.\n\n    Parameters\n    ----------\n    oxide : bool\n        Whether to include oxide calculations.\n    slabs : dict[str, Atoms], optional\n        Dictionary of slab structures to calculate.\n    run_bulk : bool\n        Whether to run bulk calculations.\n\n    Returns\n    -------\n    dict[str, tuple[dict[str, Atoms], Any]]\n        Results dictionary containing structures and calculation results.\n    \"\"\"\n\n    @subflow\n    def run_slab_calculations(structures: dict[str, Atoms]) -&gt; list[Any]:\n        \"\"\"Run relaxation calculations for slab structures.\"\"\"\n        return [\n            slab_relax_job(atoms, input_data=INPUT_DATA_SLABS)\n            for atoms in structures.values()\n        ]\n\n    @subflow\n    def run_bulk_calculations(structures: dict[str, Atoms]) -&gt; list[Any]:\n        \"\"\"Run relaxation calculations for bulk structures.\"\"\"\n        return [\n            bulk_relax_job(atoms, input_data=INPUT_DATA_BULK)\n            for atoms in structures.values()\n        ]\n\n    stable_structures_oxide = generate_stable_oxides() if oxide else {}\n    chempot_reference_structures = reference_structures(oxide=oxide)\n    stable_structures_element = generate_stable_elements()\n\n    results = {\n        \"slabs\": (slabs, run_slab_calculations(slabs)) if slabs else (None, None)\n    }\n\n    if run_bulk:\n        results.update(\n            {\n                \"references\": (\n                    chempot_reference_structures,\n                    run_bulk_calculations(chempot_reference_structures),\n                ),\n                \"elements\": (\n                    stable_structures_element,\n                    run_bulk_calculations(stable_structures_element),\n                ),\n                \"oxides\": (\n                    stable_structures_oxide,\n                    run_bulk_calculations(stable_structures_oxide),\n                ),\n            }\n        )\n    else:\n        results.update(\n            {\n                \"references\": (chempot_reference_structures, None),\n                \"elements\": (stable_structures_element, None),\n                \"oxides\": (stable_structures_oxide, None),\n            }\n        )\n\n    return results\n</code></pre>"},{"location":"reference/wulfflow/workflow/generator.html","title":"generator","text":""},{"location":"reference/wulfflow/workflow/generator.html#wulfflow.workflow.generator.create_unique_label","title":"create_unique_label","text":"<pre><code>create_unique_label(miller, slab)\n</code></pre> <p>Create a unique label for a slab.</p> <p>Parameters:</p> <ul> <li> <code>miller</code>               (<code>tuple[int, int, int]</code>)           \u2013            <p>Miller indices of the slab.</p> </li> <li> <code>slab</code>               (<code>Atoms</code>)           \u2013            <p>The slab structure.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>Unique label for the slab.</p> </li> </ul> Source code in <code>wulfflow/workflow/generator.py</code> <pre><code>def create_unique_label(miller: tuple[int, int, int], slab: Atoms) -&gt; str:\n    \"\"\"\n    Create a unique label for a slab.\n\n    Parameters\n    ----------\n    miller : tuple[int, int, int]\n        Miller indices of the slab.\n    slab : Atoms\n        The slab structure.\n\n    Returns\n    -------\n    str\n        Unique label for the slab.\n    \"\"\"\n    z_positions = slab.positions[:, 2]\n    termination_atoms = slab[z_positions &gt; max(z_positions) - 0.1]\n\n    miller_str = \"\".join(map(str, miller))\n    termination_formula = termination_atoms.get_chemical_formula()\n    position_hash = blake2s(slab.positions.tobytes(), digest_size=8).hexdigest()\n\n    return f\"{miller_str}_{termination_formula}_{position_hash}\"\n</code></pre>"},{"location":"reference/wulfflow/workflow/generator.html#wulfflow.workflow.generator.generate_slabs","title":"generate_slabs","text":"<pre><code>generate_slabs(input_file, write_xyzs=False)\n</code></pre> <p>Generate slabs from an input file.</p> <p>Parameters:</p> <ul> <li> <code>input_file</code>               (<code>str</code>)           \u2013            <p>Path to the input file.</p> </li> <li> <code>write_xyzs</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to write the slabs to XYZ files. Defaults to False.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Atoms]</code>           \u2013            <p>Dictionary of generated slabs.</p> </li> </ul> Source code in <code>wulfflow/workflow/generator.py</code> <pre><code>def generate_slabs(input_file: str, write_xyzs: bool = False) -&gt; dict[str, Atoms]:\n    \"\"\"\n    Generate slabs from an input file.\n\n    Parameters\n    ----------\n    input_file : str\n        Path to the input file.\n    write_xyzs : bool, optional\n        Whether to write the slabs to XYZ files. Defaults to False.\n\n    Returns\n    -------\n    dict[str, Atoms]\n        Dictionary of generated slabs.\n    \"\"\"\n    bulk = read(input_file)\n    pmg_structure = AseAtomsAdaptor.get_structure(bulk)\n    pmg_slabs = generate_all_slabs(pmg_structure, **SLAB_GENERATOR_FLAGS)\n\n    slab_dictionary = {}\n\n    for pmg_slab in pmg_slabs:\n        miller = tuple(pmg_slab.miller_index)\n        ase_slab = AseAtomsAdaptor.get_atoms(pmg_slab.get_orthogonal_c_slab())\n        slab_name = create_unique_label(miller, ase_slab)\n\n        if slab_name in slab_dictionary:\n            print(f\"Warning: Duplicate slab name: {slab_name}. Skipping.\")\n            continue\n\n        ase_slab.info[\"miller_index\"] = miller\n        slab_dictionary[slab_name] = ase_slab\n\n    if write_xyzs:\n        slab_dir = Path(\"slabs\")\n        slab_dir.mkdir(exist_ok=True)\n        for key, slab in slab_dictionary.items():\n            write(slab_dir / f\"{key}.xyz\", slab)\n\n    return slab_dictionary\n</code></pre>"},{"location":"reference/wulfflow/workflow/generator.html#wulfflow.workflow.generator.generate_stable_elements","title":"generate_stable_elements","text":"<pre><code>generate_stable_elements(output_dir='on_hull_elements')\n</code></pre> <p>Generate stable elements and save them to the output directory.</p> <p>Parameters:</p> <ul> <li> <code>output_dir</code>               (<code>str</code>, default:                   <code>'on_hull_elements'</code> )           \u2013            <p>Directory to save the stable elements. Defaults to \"on_hull_elements\".</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Atoms]</code>           \u2013            <p>Dictionary of stable elements.</p> </li> </ul> Source code in <code>wulfflow/workflow/generator.py</code> <pre><code>def generate_stable_elements(output_dir: str = \"on_hull_elements\") -&gt; dict[str, Atoms]:\n    \"\"\"\n    Generate stable elements and save them to the output directory.\n\n    Parameters\n    ----------\n    output_dir : str, optional\n        Directory to save the stable elements. Defaults to \"on_hull_elements\".\n\n    Returns\n    -------\n    dict[str, Atoms]\n        Dictionary of stable elements.\n    \"\"\"\n    structure = Structure.from_file(CIF_FILE_PATH)\n    elements = list(\n        {\n            element.symbol\n            for element in structure.composition.elements\n            if element.symbol != \"O\"\n        }\n    )\n    stable_entries = get_stable_structures(elements)\n\n    stable_structures_element = {}\n\n    for entry in stable_entries:\n        if len(entry.composition.elements) == 1:\n            formula = entry.composition.reduced_formula\n            structure = entry.structure\n            ase_atoms = AseAtomsAdaptor.get_atoms(structure)\n            stable_structures_element[formula] = ase_atoms\n            save_structure(ase_atoms, formula, output_dir)\n\n    return stable_structures_element\n</code></pre>"},{"location":"reference/wulfflow/workflow/generator.html#wulfflow.workflow.generator.generate_stable_oxides","title":"generate_stable_oxides","text":"<pre><code>generate_stable_oxides(output_dir='on_hull_oxides')\n</code></pre> <p>Generate stable oxides and save them to the output directory.</p> <p>Parameters:</p> <ul> <li> <code>output_dir</code>               (<code>str</code>, default:                   <code>'on_hull_oxides'</code> )           \u2013            <p>Directory to save the stable oxides. Defaults to \"on_hull_oxides\".</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Atoms]</code>           \u2013            <p>Dictionary of stable oxides.</p> </li> </ul> Source code in <code>wulfflow/workflow/generator.py</code> <pre><code>def generate_stable_oxides(output_dir: str = \"on_hull_oxides\") -&gt; dict[str, Atoms]:\n    \"\"\"\n    Generate stable oxides and save them to the output directory.\n\n    Parameters\n    ----------\n    output_dir : str, optional\n        Directory to save the stable oxides. Defaults to \"on_hull_oxides\".\n\n    Returns\n    -------\n    dict[str, Atoms]\n        Dictionary of stable oxides.\n    \"\"\"\n    structure = Structure.from_file(CIF_FILE_PATH)\n    elements = list({element.symbol for element in structure.composition.elements})\n    stable_entries = get_stable_structures(elements)\n\n    stable_structures_oxide = {}\n\n    for entry in stable_entries:\n        if (\n            \"O\" in entry.composition.reduced_formula\n            and len(entry.composition.elements) == 2\n        ):\n            formula = entry.composition.reduced_formula\n            structure = entry.structure\n            ase_atoms = AseAtomsAdaptor.get_atoms(structure)\n            stable_structures_oxide[formula] = ase_atoms\n            save_structure(ase_atoms, formula, output_dir)\n\n    return stable_structures_oxide\n</code></pre>"},{"location":"reference/wulfflow/workflow/generator.html#wulfflow.workflow.generator.get_stable_structures","title":"get_stable_structures","text":"<pre><code>get_stable_structures(elements)\n</code></pre> <p>Get stable structures for given elements.</p> <p>Parameters:</p> <ul> <li> <code>elements</code>               (<code>list[str]</code>)           \u2013            <p>List of element symbols.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[PDEntry]</code>           \u2013            <p>List of stable phase diagram entries.</p> </li> </ul> Source code in <code>wulfflow/workflow/generator.py</code> <pre><code>def get_stable_structures(elements: list[str]) -&gt; list[PDEntry]:\n    \"\"\"\n    Get stable structures for given elements.\n\n    Parameters\n    ----------\n    elements : list[str]\n        List of element symbols.\n\n    Returns\n    -------\n    list[PDEntry]\n        List of stable phase diagram entries.\n    \"\"\"\n    with MPRester(API_KEY) as mpr:\n        entries = mpr.get_entries_in_chemsys(elements)\n        pd = PhaseDiagram(entries)\n        return pd.stable_entries\n</code></pre>"},{"location":"reference/wulfflow/workflow/generator.html#wulfflow.workflow.generator.reference_structures","title":"reference_structures","text":"<pre><code>reference_structures(output_dir='reference_structures', oxide=True)\n</code></pre> <p>Generate reference structures and save them to the output directory.</p> <p>Parameters:</p> <ul> <li> <code>output_dir</code>               (<code>str</code>, default:                   <code>'reference_structures'</code> )           \u2013            <p>Directory to save the reference structures. Defaults to \"reference_structures\".</p> </li> <li> <code>oxide</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to include oxygen in the reference structures. Defaults to True.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Atoms]</code>           \u2013            <p>Dictionary of reference structures.</p> </li> </ul> Source code in <code>wulfflow/workflow/generator.py</code> <pre><code>def reference_structures(\n    output_dir: str = \"reference_structures\", oxide: bool = True\n) -&gt; dict[str, Atoms]:\n    \"\"\"\n    Generate reference structures and save them to the output directory.\n\n    Parameters\n    ----------\n    output_dir : str, optional\n        Directory to save the reference structures. Defaults to \"reference_structures\".\n    oxide : bool, optional\n        Whether to include oxygen in the reference structures. Defaults to True.\n\n    Returns\n    -------\n    dict[str, Atoms]\n        Dictionary of reference structures.\n    \"\"\"\n    structures = {}\n    bulk_structure = Structure.from_file(CIF_FILE_PATH)\n    bulk_atoms = AseAtomsAdaptor.get_atoms(bulk_structure)\n    bulk_formula = bulk_structure.composition.reduced_formula\n    structures[bulk_formula] = bulk_atoms\n    save_structure(bulk_atoms, bulk_formula, output_dir)\n\n    if oxide:\n        o2_molecule = molecule(\"O2\")\n        o2_molecule.set_cell([10, 10, 10])\n        o2_molecule.center()\n        structures[\"O2\"] = o2_molecule\n        save_structure(o2_molecule, \"O2\", output_dir)\n\n    return structures\n</code></pre>"}]}